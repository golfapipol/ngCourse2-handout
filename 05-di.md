# Part 5: Angular 2 Dependency Injection 

Dependency injection (DI) was a core feature in Angular 1.x, and that has not changed in Angular 2.  DI is a programming concept that predates Angular.  The purpose of DI is to simplify dependency management in software components. By reducing the amount of information a component needs to know about its dependencies, unit testing can be made easier, and code is more likely to be flexible.

Angular 2 improves on Angular 1.x's DI model by unifying Angular 1.x's two injection systems.  Tooling issues with respect to static analyis, and minification have also been fixed in Angular 2.  Namespace collisions have also been addressed in Angular 2.

## What Is DI?

So dependency injection makes programmers' lives easier, but what does it
_really_ do?

Consider the following code:

```js

class Hamburger {
  private bun: Bun;
  private patty: Patty;
  private toppings: Toppiongs;
  constructor(Bun, Patty, Toppings) {
    this.bun = new Bun('withSesameSeeds');
    this.patty = new Patty('beef');
    this.toppings = new Toppings(['lettuce', 'pickle', 'tomato']);
  }
}

```

The above code is a contrived class that represents a hamburger.  The class
assumes a hamburger consists of a bun, patty, and topping.  The class is also
responsible for _making_ the bun, patty, and topping.  This is a bad thing.
What if a vegetarian burger were needed?  One naive approach might be:

```js

class VeggieHamburger {
  private bun: Bun;
  private patty: Patty;
  private toppings: Toppiongs;
  constructor(Bun, Patty, Toppings) {
    this.bun = new Bun('withSesameSeeds');
    this.patty = new Patty('tofu');
    this.toppings = new Toppings(['lettuce', 'pickle', 'tomato']);
  }
}
```

There, problem solved right? But what if we need a gluten free hamburger? What
about if we want different toppings... maybe something more generic like:

```js

class Hamburger {
  private bun: Bun;
  private patty: Patty;
  private toppings: Toppiongs;
  constructor(bunType: string, pattyType: string, toppings: string[]) {
    this.bun = new Bun(bunType);
    this.patty = new Patty(pattyType);
    this.toppings = new Toppings(toppings);
  }
}
```

Okay this is a little different, and it's more flexible in some ways, but it is
still quite brittle.  What would happen if the `Patty` constructor changed to
allow for new features?  The whole `Hamburger` class would have to be updated.
In fact, any time any of these constructors used in `Hamburger`'s constructor
are changed, `Hamburger` would also have to be changed.

Also, what happens during testing? How can `Bun`, `Patty`, and `Toppings` be
effectively mocked?

Taking those concerns into considerdation, the class could be re-written as:

```js

class Hamburger {
  private bun: Bun;
  private patty: Patty;
  private toppings: Toppiongs;
  constructor(bun: Bun, patty: Patty, toppings: Toppings) {
    this.bun = bun;
    this.patty = patty;
    this.toppings = toppings;
  }
}
```

Now when `Hamburger` is instantiated it does not need to know anything about its
`Bun`, `Patty`, or `Toppings`.  The construction of these elements has been
moved out of the class.  This pattern is so common that TypeScript allows it to
be written in shorthand like so:

```js

class Hamburger {
  constructor(private bun: Bun, private patty: Patty, 
    private toppings: Toppings) {}
}
```


The `Hamburger` class is now simpler, and easier to test.  This model of having
the dependencies provided to `Hamburger` is basic dependency injection.

However there is still a problem.  How can the instantiation of `Bun`, 
`Patty`, and `Toppings` best be managed?

This is where dependency injection as a _framework_ can benefit programmers, and
it is what Angular 2 provides with its dependency injection system.

## DI Framework

So there's a fancy new `Hamburger` class that is easy to test, but it's
currently awkward to work with.  Instantiating a `Hamburger` requires:

```js

const hamburger = new Hamburger(new Bun(), new Patty('beef'), new Toppings([]));
```

That's a lot of work to create a `Hamburger`, and now all the different pieces
of code that make `Hamburger`s have to understand how `Bun`, `Patty`, and 
`Toppings` get instantiated.

One approach to dealing with this new problem might be to make a factory
function like so:

```js

function makeHamburger() {
    const bun = new Bun();
    const patty = new Patty('beef');
    const toppings = new Toppings(['lettuce', 'tomato', 'pickles']);
    return new Hambuerger(bun, patty, toppings);
}
```

This is an improvement, but when more complex `Hamburger`s need to be created
this factory will become confusing.  The factory is also responsible for 
knowing how to create four different components.  This is a lot for one
function.

This is really where a dependency injection framework can help.  DI Frameworks
generally have the concept of an `Injector` object.  An Injector is a lot like
the factory function above, but more general, and powerful.  Instead of one
giant factory function, an Injector has a factory, or _recipe_ (pun intended)
for a collection of objects.  With an `Injector` creating a `Hamburger` could be
as easy as:

```js

const injector = new Injector([Hamburger, Bun, Patty, Toppings]);
const burger = injector.get(Hamburger);
```

## Angular 2's DI

The last example introduced a hypothetical `Injector` object.  Angular 2 
simplifies DI even further.  With Angular 2, developers almost never have to get
bogged down with injection details.

Angular 2's DI system is very subtle.  It's not obvious, but calling Angular 2's
bootstrap function initializes Angular 2's injection framework.

For example:

```js

import {bootstrap} from 'angular2/core';
import {App} from './path/to/your/root/component';

bootstrap(App)
```

Believe it or not, the above example creates the root injector.  This example is
too primitive though, the injector is not told about anything.

```js
import {bootstrap, Injectable} from 'angular2/core';
import {App} from './path/to/your/root/compoent';

@Injectable()
class Hamburger {
  constructor(private bun: Bun, private patty: Patty, 
    private toppings: Toppings) {}
}

bootstrap(App, [Hamburger]);
```

In the above example the root injector is initialized, and told about the
`Hamburger` class.

That seems pretty straightforward, but astute readers will be wondering how
Angular 2 knows how to build `Hamburger`.  What if `Hamburger` was a string, or
a plain function? 

Angular 2 _assumes_ that it's being given a class.

What about `Bun`, `Patty`, and `Toppings`, how is `Hamburger` getting those?

It's not, at least not yet.  Angular 2 does not know about them yet.  That can
be changed easily enough:

```js
import {bootstrap, Injectable} from 'angular2/core';
import {App} from './path/to/your/root/compoent';

@Injectable()
class Hamburger {
  constructor(private bun: Bun, private patty: Patty, 
    private toppings: Toppings) {}
}

@Injectable()
class Patty {}

@Injectable()
class Bun {}

@Injectable()
class Toppings {}

bootstrap(App, [Hamburger, Patty, Bun, Toppings]);
```

Okay, this is starting to look a little bit more complete.  Although it's still
unclear how `Hamburger` is being told about its dependencies.  Perhaps that is
related to those odd `@Injectable` statements.

### `@Injectable`

`@Injectable` is a decorator.  [Decorators][decorators] are a proposed extension
to JavaScript.  In short decorators let developers modify, and/or tag methods,
classes, properties, and parameters.  There is a lot to decorators, in this
section the focus will be on decorators relevant to DI, which are, `@Inject`,
and `@Injectable`.

Let's investigate what `@Injectable` does.  The following TypeScript:

```js
import {Injectable} from 'angular2/core';

@Injectable()
class Bun {}
```

Compiled with:

```bash

tsc -m commonjs -t es5 --experimentalDecorators ./test-di.ts
```

Produces ES5 that looks like:

```js

var core_1 = require('angular2/core');
var Bun = (function () {
  function Bun() {
  }
  Bun = __decorate([
    core_1.Injectable()
  ], Bun);
  return Bun;
})();
```

So `Bun` becomes the product of `__decorate`, which takes an Array of decorators
and the `Bun` class.  So what does `__decorate` do?

A readable version of `__decorate` looks something like:
```js

function decorators(decorators, target, key, desc) {
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") {
    return Reflect.decorate(decorators, target, key, desc);
  }
  switch (arguments.length) {
    case 2: 
      return decorators.reduceRight(function(o, d) { 
        return (d && d(o)) || o; 
      }, target);
    case 3: 
      return decorators.reduceRight(function(o, d) { 
        return (d && d(target, key)), void 0; 
      }, void 0);
    case 4: 
      return decorators.reduceRight(function(o, d) { 
        return (d && d(target, key, o)) || o; 
      }, desc);
  }
};
```




## Simple Service Example

This example demonstrates injecting Angular's http service into a TypeScript class

```js
import {Injectable} from 'angular2/core';
// import the dependency for its _typings_
// *note* Http is _not_ used/instantiated in this module, it is injected
import {Http} from 'angular2/http';

@Injectable() // <- do not forget brackets after @Injectable!!
export class Dependent {
    constructor(public http:Http) {}
    someMethod() {
        this.http.get()
        ...
    }
}
```

Dependent is a simple TypeScript class that has been decorated with `@Injectable`.  This [decorator][pascalDIservice] is a shortcut for a more verbose `@Inject` syntax.  This decorator essentially tells Angular 2 that this class is going to be injected with dependencies.  Angular 1.x developers can
think of it like `/* @ngInject */`.

This example is also odd in that `Http` is imported even though it's going to be injected.  This import statement only pulls in the Http module from Angular 2. The Angular 2 injector is ultimately responsible for _instantiating_ `Http`, and _providing_ it to `Dependent`

## Simple Component Example

In this example we have a custom service:

```js
import {Injectable} from 'angular2/core';

@Injectable()
export class CustomService {
    getData() {
        return 'fancy data';
    }
}
```

Which is a dependency of a simple component:

```js
import {Component} from 'angular2/core';
import {CustomService} from './custom-service';

@Component({
    selector: 'simple-component',
    template: '<div>{{ output }}</div>',
    providers: [CustomService]
})
export class SimpleComponent {
    constructor(private customService: CustomService) {
        this.output = customService.getData();
    }
    output: string;
}
```

Using DI with components is the same as with plain services.  The important difference in this example is the `providers` array in the component decorator. The `providers` array is a mechanism for letting Angular 2's injector know about `CustomService`, and how to build it.  In this example `providers` was given only a class name, and Angular _inferred_ what to do with it.

## Using `providers` to Specify Alternate `CustomService`'s

The `providers` mechanism allows the programmer to specify mechanisms other than classes.  The above component example's `providers` array is really just a shorthand for:

```js
import {provide} from 'angular2/core';

...
providers: [provide(CustomService, {useClass: CustomService})]
...

```

The shorthand syntax eliminates a _lot_ of boilerplate.  The longhand syntax hints at the power of Angular 2's injector.

Instead of using a formal class in the previous example, it could be re-written to use an inline object.  (In the real world the formal class is likely the better option)

```js

import {Component} from 'angular2/core';
import {provide} from 'angular2/core';

var mockService = { getData: () => 'fancy data' };

@Component({
    selector: 'simple-component',
    template: '<div>{{ output }}</div>',
    providers: [provide(CustomService, { useValue: mockService })]
})
export class SimpleComponent {
    constructor(private customService: CustomService) {
        this.output = customService.getData();
    }
    output: string;
}
```

In this example Angular 2 knows that `CustomService` is a "value", and instead of instantiating under the hood (`new CustomService`), Angular 2 will simply return the value _provided_.

## Singletons

Angular 2 injectors (generally) return singletons.  That is, in the previous example, any _child_ components of `SimpleComponent` will receive the _same_ `CustomService` that `SimpleComponent` got.

## The Injector Tree

In Angular 2 there is not just one injector per application, there is _at least_ one injector per application.  Injectors are organized in a tree that parallels Angular 2's component tree.

The injector tree does _not_ make a new injector for every component.  The injector tree _does_ make a new injector for every component with a `providers` array in its decorator.  Components that have no `providers` array look to their parent component for an injector. If the parent does not have an injector, it looks up on, and on until it reaches the root injector.

_Warning:_ be careful with `provider` arrays.  If a child component is decorated with a `providers` array, and that array contains dependencies that were _also_ requested in the parent component(s) the dependencies the child receives will _shadow_ the parent dependencies.  This can have all sorts of negative consequences.

[SODi]: http://stackoverflow.com/questions/130794/what-is-dependency-injection "Community Answers To What Is DI?"
[pascalDI]: http://blog.thoughtram.io/angular/2015/05/18/dependency-injection-in-angular-2.html "Dependency Injection in Angular 2"
[pascalDIservice] http://blog.thoughtram.io/angular/2015/09/17/resolve-service-dependencies-in-angular-2.html "Service in Service DI"
[a2DImanual]: https://angular.io/docs/ts/latest/guide/dependency-injection.html "Angular 2's Beta docs for DI"
[decorators]: http://blog.wolksoftware.com/decorators-reflection-javascript-typescript "ES Decorators Explained"